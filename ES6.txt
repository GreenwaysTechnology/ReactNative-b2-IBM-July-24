			 ES 6 - Java script
.....................................................................................

What is Javascript?

 Java script is object based, functional style programming language.

What is Object based


Object Orientation:
..................

 Object orientation is style of architecting apps.

IS there is any other styles?

1.Producure oriented style
2.Object oriented style
3.Functional programming style

Object oriented Programming:  
  Collection of object oriented principles.

OO Principles:
..............
1.Abstraction - Describes how to collect and analysis req -class,interface
2.Encaspulation - Tells how to share code and how to not share code
3.Modularity - How to break the code into files and folders - namepaces,packages
4.Hierachy - how to establish realtionship among classes - is-a(inheritance),has-a(dependency)
5.Typing - Data Types - Strong typing,weak Typing- Polymorphism (only for                         polymorphism)
 
  Strong Typing:
    int a =10;
   here a's type is verified during compile time
    a="hello" 
   here compiler catches error.
  The type of variable is verified during compile time

 var a =10
   here a's type is not verifed during compile time rather runtime.
  These types are called weak typed.
.................
6.Concurrency -  Processing represenation - threads
7.Persistancy - Storage

C#,java,kotlin,swift is object oriented language.

if any programming language follows oo 1 to 5 principles , those languages called as "Object oriented Language".

if any programming language does not follow oo 1 to 5 principles completly or partially , those languages called as "Object based Language".

Functional Programming:
  It is also style of programming..

SOme programming languages follows single style - c++ - object oriented language
Some programming languages follows multiple style - hybrid language.

JS is hybrid language.
  It supports both object based and functional language.

Javascript language runtime Environment:
........................................

Life cycle of programming

java
1.source code  - hello.java -english
2.compiled code - hello.class - assembly
...............................Dev Cycle
3.Excutable code  -----Runtime - jvm

JS:
1.source code - hello.js 
    |
  compiled --->

JS Runtime:
  It is program which is responsible for loading,parsing,compiling,running js code.

Where is js runtime?

  Every browser has embeded js runtime.

Chrome-V8
Edge - Chakra
Firefox - Spider Monkey
 
 Js engine is available outside browser too, which is called "Node.js"
 
JS engine is available in mobile -via React Native -Hermes
...................................................................................
			 language
...................................................................................

Versions:
 Js language was created by Netscap communications on 1995.

 After javascript language created, the language was submitted to standard body called "ECMA" international.

After that Js was called as ECMA Script or ES.

After submission, the language was standarized and released by committee.

1.ES 1.0 -->1996
2.ES 3.0 -->1999
3.ES 4.0 -->2006
4.ES 5.0 --->2007
5.ES 6.0 --->2012-2015
6.ES 7.0 ----->2016
 still growing but up to es 7 is stable and in production....
etc.....

Javascript learning path(ES6):
..............................
1.Language fundamentals
2.Functions 
3.Objects

1.Language fundamentals
 ->Variables
 ->Literals
 ->Type Systems


1.Language fundamentals:

variables,type system,values(literals)

var,let,const

literals:(values)

  literal   - type
....................
  string    - string
  number    - number
  boolean   - boolean
  undfined   - undefined
  NaN       - number
  Infinity  - number
  function  - function
  object    - object
  null      - object

type system;

1.string
2.number
3.object
4.boolean
5.undefined
6.function
.....................................................................................
			    
Software setup:
1.node.js
2.vs code
3.Jdk 17
4.Android Studio
.....................................................................................

Project Setup:
..............

G:\IBM\2024\July\ReactNative-b2>mkdir es6apps
G:\IBM\2024\July\ReactNative-b2>cd es6apps

G:\IBM\2024\July\ReactNative-b2\es6apps>mkdir src

G:\IBM\2024\July\ReactNative-b2\es6apps>code .

Helloworld
src/index.js
console.log('Hello')

How to test?
 we are going to test using browser, so we need html file.


es6apps
  | 
  src
 |
 index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6 apps</title>
</head>
<body>
    <h1>ES6 apps</h1>
    <script src="src/index.js"></script>
</body>
</html>

How to run this file?

 in order to we web server.
 vs code offers embeded webserver , that needs to be installed.

vs code--->Extension---live server---->click --->install-->restart vs code.

After installing live server, right click on html, lanuch server along with index.html

After lanuching, right click on browser,click inspect, go to console.

....................................................................................
....................................................................................
				Variables,data types,Literals
.....................................................................................

JS is dynamically typed,so type is not declared in advance, type of variables are decided during runtime, based on "literals-values"

Js has 9 literals but only 6 types.

strings,numbers,boolean,undefined,object,function- types

//strings

let firstName="Subramanian"
let lastName='Murugan'
//back tick and string interpolation: es 6 feature
//let fullName = firstName + lastName
let fullName =`${firstName} ${lastName}`
console.log("Your Name " + fullName)
console.log("Your Name",fullName)
console.log(`Your name ${fullName}`)


Numbers:
 only type called number 
 64 bit aka double.

//numbers
let qty = 10
let price = 10.45
let total = qty * price
console.log(`Total ${total}`)


Booleans:
 true or false

//true or false 

//boolean
let isLoggedIn = true
let isDisabled = false

console.log(`Is LoggedIn ${isLoggedIn} Is Disabled ${isDisabled}`)


Undefined:
 Variable is declared without any valid value.
//undefined

let qty;
console.log(`Quantity ${qty}`)

NaN : Not a Number

NaN is number only which represents "error".
If you do any numerical computation, if computation is failed you will get NaN.
NaN is kind of "error".
if you get NaN you have to fix beacuse is bug

NaN Use case:
if you do computation against undefined values, you get NaN.

let qty
let price=100
let total = qty * price 

console.log(`Qty ${qty} Price ${price} Total ${total}`)


Infinity:
  Div/0
//infnity
let price = 100;
let avgPrice = price / 0
console.log(`Avg Price ${avgPrice}`)
..................................................................................
			Advanced Boolean
..................................................................................
What can be true or false?

decision making : if..else ,tenary operator

in javascript is every thing is true execept the following values 

Falsy values

 * 
 *  1.boolean false
 *  2.Empty string "" ,''
 *  3.0
 *  4.undefined
 *  5.NaN
 *  6.null
 */




let message = 'Hello'

if (message) {
    console.log(message)
} else {
    console.log('wrong')
}
message = ''
if (message) {
    console.log(message)
} else {
    console.log('wrong')
}
let myvar;
if (myvar) {
    console.log(`MyVar is ${myvar}`)
} else {
    console.log(`False : MyVar is ${myvar}`)
}
myvar = 0
if (myvar) {
    console.log(`MyVar is ${myvar}`)
} else {
    console.log(`False : MyVar is ${myvar}`)
}
myvar = false
if (myvar) {
    console.log(`MyVar is ${myvar}`)
} else {
    console.log(`False : MyVar is ${myvar}`)
}
myvar = NaN
if (myvar) {
    console.log(`MyVar is ${myvar}`)
} else {
    console.log(`False : MyVar is ${myvar}`)
}

....................................................................................
				Operator -Equal
.....................................................................................

== ->Double equal
=== ->Triple equal
!=
!==

let a = 100
let b = 100
if (a == b) {
    console.log('a and b are equal')
} else {
    console.log('a and b are not equal')
}

let x = 100
let y = "100"

if (x == y) {
    console.log('x and y are equal')
} else {
    console.log('x and y are not equal')
}

if (x === y) {
    console.log('x and y are equal')
} else {
    console.log('x and y are not equal')
}
.....................................................................................
			 const
....................................................................................

let vs const

const 
 readonly,
 we cant reinitalize the variable

let a=10
console.log(`a value is ${a}`)
a=900
console.log(`a value is ${a}`)

const b=100;
console.log(`b value is ${b}`)
//you cant reinitalize
b=900
.....................................................................................
		.....................................................................................
			   Functions
....................................................................................
functions are building block of javascript language.
functions encapsulate the logic of application.
functions may take args and return values


//function declaration
function sayHello(){
    console.log('hello')
}
//function invocation
sayHello()

Function args and parameters:
..............................


//default arg
function sayHello(name = 'Default Name') {
    console.log('Your name is ', name)
}
//with parameter
sayHello('Subramanian')
//without parameter : undefined will be passed as default value
sayHello()

function multiply(a = 0, b = 0) {
    let c = a * b
    console.log('Result is ', c)
}
multiply(10, 10)
multiply()

....................................................................................
			 Return values
....................................................................................

//default arg
function sayHello(name = 'Default Name') {
   return name;
}
//with parameter
console.log(sayHello('Subramanian'))
//without parameter : undefined will be passed as default value
console.log(sayHello())

function multiply(a = 0, b = 0) {
    let c = a * b
    return c 
}
let res= multiply(10, 10)
console.log(res)
....................................................................................
			  Functional Programming
....................................................................................
According to functional programming, function is just value like numbers,strings.

since function is value can be assigned to a variable.

If you assign the function with variable, then that function can be called with variableName.

if you declare function with variables, without function name called "Anonymous function".

//function literal:

//let is keyword
//a is variable
//10 is literal and its type is number
let a = 10


//let is keyword
//hello is variable
//function(){} -is value: function itself is value
//function has no any name; anonymous function
let hello = function () {
    console.log('Hello')
}
//hello variable can be used to call function
hello()

Anonymous functions args,returns:
................................

let add = function (a = 0, b = 10) {
    return a + b
}
console.log(add(10,10))
console.log(add())
			Higher order functions
....................................................................................

1.Passing function as parameter
2.Returning function 

1.Passing function as parameter

Use case : simple function

//
//a =x, b=y
function add(a, b) {
    return a + b;
}
let x = 10;
let y = 20;
console.log(add(x, y))
console.log(add(10, 10))

//higher order fun
//greet = hello =  function(){}
function sayGreet(greet) {
    greet()
}
let hello = function () {
    console.log('hello')
}
sayGreet(hello)

//passing hardcoded function
sayGreet(function () {
    console.log('welcome')
})



Use case :passing parameters and return values from hof:
function sayGreet(greet) {
    let status = greet('welcome')
    console.log(status)
}
let hello = function (message) {
    console.log(message)
    return 'processed'
}
sayGreet(hello)

//passing hardcoded function
sayGreet(function (message) {
    console.log(message)
    return "processed"
})
..........................
Use case : passing paramers with some logic - more functions as parameter.
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxxxxx

function login(userName, password, resolve, reject) {
    if (userName === 'admin' && password === 'admin') {
        resolve('login success')
    } else {
        reject('login failed')
    }

}

login('admin', 'admin', function (status) {
    console.log(status)
}, function (err) {
    console.log(err)
})

login('foo', 'bar', function (status) {
    console.log(status)
}, function (err) {
    console.log(err)
})
....................................................................................
			Higher order functions in ES 6
			   (Arrow Functions)

Arrow functions are just replace of old(es5) anonymous function syntax.

Arrow functions looks very simple ,less code
....................................................................................
			Higher order functions
....................................................................................

1.Passing function as parameter
2.Returning function 

1.Passing function as parameter

Use case : simple function

//
//a =x, b=y
function add(a, b) {
    return a + b;
}
let x = 10;
let y = 20;
console.log(add(x, y))
console.log(add(10, 10))

//higher order fun
//greet = hello =  function(){}
function sayGreet(greet) {
    greet()
}
let hello = function () {
    console.log('hello')
}
sayGreet(hello)

//passing hardcoded function
sayGreet(function () {
    console.log('welcome')
})



Use case :passing parameters and return values from hof:
function sayGreet(greet) {
    let status = greet('welcome')
    console.log(status)
}
let hello = function (message) {
    console.log(message)
    return 'processed'
}
sayGreet(hello)

//passing hardcoded function
sayGreet(function (message) {
    console.log(message)
    return "processed"
})
..........................
Use case : passing paramers with some logic - more functions as parameter.

function login(userName, password, resolve, reject) {
    if (userName === 'admin' && password === 'admin') {
        resolve('login success')
    } else {
        reject('login failed')
    }
}

login('admin', 'admin', function (status) {
    console.log(status)
}, function (err) {
    console.log(err)
})

login('bar', 'foo', function (status) {
    console.log('login success')
}, function (err) {
    console.log('login failed')
})
.....................................................................................
	   Higher order function - return  function from another function
.....................................................................................

Use case : Nested function:


function makeCoffee() {
    //nested fun
    function start() {
        console.log('starting')
    }
    //calling nested fun
    start()
}
makeCoffee()

Use case : calling nested function : hof

// function makeCoffee() {
//     function start() {
//         console.log('starting')
//     }
//     return start

// }
// function makeCoffee() {
//     return function start() {
//         console.log('starting')
//     }
//     //return start

// }
// function makeCoffee() {
//     return function () {
//         console.log('starting')
//     }
//     //return start

// }
// // let myfun = makeCoffee()
// // myfun()
// makeCoffee()()

function makeCoffee() {
    return function (status) {
        console.log(status)
    }
    //return start

}
// let myfun = makeCoffee()
// myfun()
makeCoffee()('starting')
....................................................................................
			Higher order functions in ES 6
			   (Arrow Functions)

Arrow functions are just replace of old(es5) anonymous function syntax.

Arrow functions looks very simple ,less code


Use case: simple arrow

//es 5 style
let hello = function () {
    console.log('hello')
}
hello()

//es 6 arrow style
let hai = () => {
    console.log('hai')
}

hai()

Use case: parameters,arg,no default arg

//code refactoring

//if function body has only one line of code, we can remove {}
// let hai = () => {
//     console.log('hai')
// }
let hai = () => console.log('hai')
hai()

//parameters
let add = (a = 0, b = 0) => {
    let c = a + b
    console.log(c)
}
add(10, 10)
//return 
// let multiple = (a = 0, b = 0) => {
//     return a * b 
// }
// console.log(multiple(10,10))

//function having only return, then we can remove {} and return statement
let multiple = (a = 0, b = 0) => a * b
console.log(multiple(10, 10))


//if function takes single arg, no default value,return the same; we can remove {},return

let getStock = value => value

console.log(getStock(34))
..................................................................................
			 Arrow and higher order function
.................................................................................

//passing function as parameter

let login = (userName, password, resolve, reject) => {
    if (userName === 'admin' && password === 'admin') {
        resolve('login success')
    } else {
        reject('login failed')
    }
}
// login('admin', 'admin', (status) => {
//     console.log(status)
// }, (err) => {
//     console.log(err)
// })
login('admin', 'admin', status => console.log(status), err => console.log(err))
		.....................................................................................
				  Objects
.....................................................................................			
Objects can be created in two ways

1.constructors pattern
   es 5 functions 
   es 6 classes
2.literal pattern

//class declaration

class Employee {
    //instance variables
    id = 1
    name = 'Subramanian'

    //methods
    calculateSalary() {
        return 100
    }
    calculateTax = () => {
        return 10
    }
}

//create instance

//let is keyword
//emp is reference variable
//new is operator
//Employee() is constructor call
let emp = new Employee()
console.log(emp)

console.log(`id ${emp.id}`)
console.log(`name ${emp.id}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)
................................................................................

State Initalization

1.inside class 
2.inside constructor
3.outside class- after object creation.

//class declaration

class Employee {
    //inside class
    id = 1
    name = 'Subramanian'

    //methods
    calculateSalary() {
        return 100
    }
    calculateTax = () => {
        return 10
    }
}

//create instance

//let is keyword
//emp is reference variable
//new is operator
//Employee() is constructor call
let emp = new Employee()
console.log(emp)

console.log(`id ${emp.id}`)
console.log(`name ${emp.id}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)


constructor parameter:

class Employee {
    id
    name
    constructor(id = 1, name = 'Subramanian') {
        this.id = id
        this.name = name
    }

    //methods
    calculateSalary() {
        return 100
    }
    calculateTax = () => {
        return 10
    }
}
let emp = new Employee()
console.log(emp)

console.log(`id ${emp.id}`)
console.log(`name ${emp.id}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)


emp= new Employee(2,'Ram')
console.log(emp)

console.log(`id ${emp.id}`)
console.log(`name ${emp.id}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)

after object creation:

class Employee {
    id
    name
    constructor(id = 1, name = 'Subramanian') {
        this.id = id
        this.name = name
    }

    //methods
    calculateSalary() {
        return 100
    }
    calculateTax = () => {
        return 10
    }
}
let emp = new Employee()
console.log(emp)

console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)


emp = new Employee(2, 'Ram')
console.log(emp)

console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)

emp = new Employee()

emp.id = 90
emp.name = 'John'

console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`salary ${emp.calculateSalary()}`)
console.log(`Tax ${emp.calculateTax()}`)
.....................................................................................
			 Hierachy
.....................................................................................

1.HAS-A 
2.IS-A -  inheritance

Has-a:
class Address {
    city
    constructor(city = 'city') {
        this.city = city
    }
}
class Employee {
    id
    name
    address
    constructor(id = 0, name = 'name', address = new Address('city')) {
        this.id = id
        this.name = name
        this.address = address
    }
}
let emp = new Employee(1, 'Subramaian', new Address('coimbatore'))
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`city ${emp.address.city}`)

IS-A inheritance
................
class Account {
    constructor() {
        console.log('account')

    }
    deposit() {
        return 100
    }
}
class SavingsAccount extends Account {
    constructor() {
        super()
        console.log('savings account')
        
    }
    deposit() {
        return 1000 + super.deposit()
    }
}
let sb = new SavingsAccount()
console.log(sb.deposit())

Note:
 mixin
 Typescript - interfaces
....................................................................................
				literal 
....................................................................................

No class,function


syntax:

let variable = {
  key:value,
  key:value
}

//
let employee = {
    id: 1,
    name: 'Subramanian'
}
console.log(`Id ${employee.id}`)
console.log(`Name ${employee.name}`)

has-a/nested object
let employee = {
    id: 1,
    name: 'Subramanian',
    //has-a
    address: {
        city: 'Coimbatore'
    }
}
console.log(`Id ${employee.id}`)
console.log(`Name ${employee.name}`)
console.log(`Name ${employee.address.city}`)

Javascripts supports lot of built in objects
.............................................

1.Browser related objects
 window,document,history,sessionStorage,localStorage etc...

2.Plain objects/POJOs

1.Object - Super Most parent object
2.Array - To implement ds in js - List
3.JSON  - Json Parser Object
4.String
5.Number
6.Boolean
7.Math
etc....

Array:
......
  Array is object which holds any type of data including other arrays.
Since array object has many methods.

//array can hold any values- numbers,strings,objects, even another array

let names = ['subu', 'ram', 'chandan']

names.forEach(item => console.log(item))

let users = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
    { id: 3, name: 'c' },
    { id: 4, name: 'd' },
]
users.forEach(item => console.log(item.id, item.name))

const res = users.map(item => {
    return item.name.toUpperCase()
})
console.log(res)

const result = users.filter(item => item.name === 'a')
console.log(result)

const user = users.find(item => item.name === 'a')
console.log(user)

const savedUser = users.concat({ id: 4, name: 'abc' })
console.log(savedUser)

Reference:
https://www.w3schools.com/jsref/jsref_find.asp
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
..................................................................................
			Object Destructuring
...................................................................................
//object destructuring: es 6 feature

// function printEmployee(emp) {
//     console.log(`Id : ${emp.id}`)
//     console.log(`Name : ${emp.name}`)
//     console.log(`City : ${emp.address.city}`)
// }

// function printEmployee(emp) {
//     //destructure
//     const { id, name, address } = emp
//     console.log(`Id : ${id}`)
//     console.log(`Name : ${name}`)
//     console.log(`City : ${address.city}`)
// }


// function printEmployee(emp) {
//     //destructure
//     const { id, name, address: { city } } = emp
//     console.log(`Id : ${id}`)
//     console.log(`Name : ${name}`)
//     console.log(`City : ${city}`)
// }

// function printEmployee({ id, name, address: { city } }) {
//     console.log(`Id : ${id}`)
//     console.log(`Name : ${name}`)
//     console.log(`City : ${city}`)
// }
const printEmployee = ({ id, name, address: { city } }) => {
    console.log(`Id : ${id}`)
    console.log(`Name : ${name}`)
    console.log(`City : ${city}`)
}
let employee = {
    id: 1,
    name: 'Subramanian',
    address: {
        city: 'Coimbatore'
    }

}
printEmployee(employee)
////////////////////////////////////////////////////////////////////////////////////////

//return object and destructuring

// function getStock() {
//     return {
//         id: 1,
//         symbol: 'google',
//         qty: 100,
//         price: 1000
//     }
// }
// console.log(getStock())


//dynamic object properties
// function getStock(id = 1, symbol = 'google', qty = 0, price = 0) {
//     return {
//         id: id,
//         symbol: symbol,
//         qty: qty,
//         price: price
//     }
// }
// console.log(getStock(2, 'meta', 3, 3445))
// console.log(getStock())

//apply descturing syntax
// function getStock(id = 1, symbol = 'google', qty = 0, price = 0) {
//     //left:right is same
//     //key:value is same
//     //you can descture, make it as one
//     return {
//         id,
//         symbol,
//         qty,
//         price
//     }
// }
// console.log(getStock(2, 'meta', 3, 3445))
// console.log(getStock())


// const getStock = (id = 1, symbol = 'google', qty = 0, price = 0) => {
//     return {
//         id,
//         symbol,
//         qty,
//         price
//     }
// }


.....................................................................................
				Async Programming
.....................................................................................

Async programming which does not block current thread,work is done in kernal parts.
Results are returned from the kernal using event driven arch.

How to implement async programming?

Req:
1.High level non blocking apis provided by js language.
        -timers,ajax,web socket....
2.Listener function to  handle async results which is called as callbacks.
3.Callbacks are implemented using Higher order Function(function as parameter)


Styles of writing async programming:

1.callbacks pattern
2.Promise Pattern
3.Promise with async and await
4.Reactive Programming via rxjs...
.....................................................................................

simple callback based async programming:

//timer, ajax.

function blockMe(message) {
    console.log(message)
}
function sayHello(callback) {
    // setTimeout(callback, 5000,'welcome')
    setTimeout(() => {
        callback('hello')
    }, 1000)
}

function main() {
    blockMe('start')
    sayHello(function (data) {
        console.log(data)
    })
    blockMe('end')
}
main()
....................................................................................
			   Callback chaining
...................................................................................

callback chaining the out put of one callback will be input to another callback.


//callback chaining

const getUser = (resolve, reject) => {
    console.log('getUser is called')
    let user = {
        name: 'admin'
    }
    //error
    //user = null
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, 'user not found')
    }
}
const login = (user, resolve, reject) => {
    console.log('login is called')
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, 'login success')
    } else {
        setTimeout(reject, 1000, 'login failed')
    }
}
const showdashboard = (status, resolve, reject) => {
    console.log('showdashboard is called')
    if (status === 'login success') {
        setTimeout(resolve, 1000, 'Welcome to Admin')
    } else {
        setTimeout(reject, 1000, 'Welcome to Guest')
    }
}

function main() {
    getUser((user) => {
        //calling login
        login(user, (status) => {
            //calling show dashboard
            showdashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, (err) => {
            console.log(err)
        })
    }, (err) => {
        console.log(err)
    })
}
main()

.....................................................................................
			Callback Hell
.....................................................................................
  getUser(user => {
        login(user, (status) => {
            showDashboard(status, page => {
                console.log(page)
            }, errpage => {
                console.log(errpage)
            })
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })


fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }

In the above code:

Are you able to understand code?
Are you able to debug code easily?
Are you able to scale code?

No!
 This is called "Callback Hell".


How to avoid callback hell or how to write clean async code? how to write simple async programming without callback hell?
*************************************************************************************

Promises:
.........


Promise is design pattern which hides complexity of callback patterns

Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks


In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.


.....................................................................................
			  Promise Implementation
.....................................................................................

Features of Promise Object:
1.Promise by deafult is Async. Which implements timer api with 0 ms .
2.Promise can be used with any async callback based  implementations.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Difference between callbacks and promises:

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.


....................................................................................

		Promise Implemenation: Object  creations
...................................................................................

1. Create Promise Object from Promise contructor
      new Promise()
2. Create Promise object from factory apis 
      Promise.resolve() / Promise.reject()

Promise object methods:

1.then - success
2.catch - errors
3.finally - clean up

factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

1.Promise factory api
   -success - resolve
   -failure - reject

Use case : Promise is by default async.

function blockMe(message) {
    console.log(message)
}

// function sayGreet(greet) {
//     setTimeout(greet, 0, 'hello')
// }
function sayGreet() {
    return Promise.resolve('hello')   //returns promise object with success
}



function main() {
    blockMe('start')
    //sayGreet(res => console.log(res))
    sayGreet().then(res => console.log(res))
    blockMe('end')
}
main()

Use case: how to return failure message/error 


function blockMe(message) {
    console.log(message)
}

function sayGreet() {
    return Promise.reject('oops,something went wrong')   //returns promise object with rejection
}



function main() {
    blockMe('start')
    sayGreet().catch(err => console.log(err))
    blockMe('end')
}
main()

Use case : how to return error and success based on logic..

function blockMe(message) {
    console.log(message)
}

function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('login success')
    } else {
        return Promise.reject('login failed')   //returns promise object with rejection
    }

}


function main() {
    blockMe('start')
    login('admin', 'admin')
        .then(res => console.log(res))
        .catch(err => console.log(err))
    login('foo', 'bar')
        .then(res => console.log(res))
        .catch(err => console.log(err))
    blockMe('end')
}
main()
	
Use case: how to use timer like async api with promise.for eg setTimeout.

In this case you cant use Promise.resolve/Promise.reject factory api, i need to use 
Constructor api  " new Promise()"


function blockMe(message) {
    console.log(message)
}


function login(userName, password) {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 5000, 'login is success')
        } else {
            setTimeout(reject, 5000, 'login is failed')
        }
    })

}



function main() {
    blockMe('start')
    login('admin', 'admin')
        .then(res => console.log(res))
        .catch(err => console.log(err))
    login('foo', 'bar')
        .then(res => console.log(res))
        .catch(err => console.log(err))
    blockMe('end')
}
main()
.....................

Use case :how to solve Callback hell:
.....................................
//callback chaining

const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = { name: 'admin' }
        //user = null
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { message: 'User Not found' })
        }
    })
}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'Login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}
const showDashboard = loginstatus => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (loginstatus === 'Login success') {
            setTimeout(resolve, 1000, 'Welcome to Dashboard Page')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest Page')
        }
    })
}



function main() {
    // getUser(user => {
    //     login(user, (status) => {
    //         showDashboard(status, page => {
    //             console.log(page)
    //         }, errpage => {
    //             console.log(errpage)
    //         })
    //     }, err => {
    //         console.log(err)
    //     })
    // }, err => {
    //     console.log(err)
    // })
    getUser()
        .then(user => {
            return login(user)
        })
        .then(status => {
            return showDashboard(status)
        }).then(page => {
            console.log(page)
        })
        .catch(err => console.log(err))
}
main()
...................................................................................
			Promise Chaining -Promise Hell
..................................................................................

getUser()
    .then(user => login(user))
    .then(status => console.log(status))
    .catch(err => console.log(err))

Here the code is having so many "then ables", in realtime if we have many more thens which makes code even harder.

ES 7 introduced new feature called "async and await"  which are keywords , when we resolve promises we dont need to use thens and catch.

We can write more declarative,sync style of async code.

const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = { name: 'admin' }
        //user = null
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { message: 'User Not found' })
        }
    })
}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'Login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}
const showDashboard = loginstatus => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (loginstatus === 'Login success') {
            setTimeout(resolve, 1000, 'Welcome to Dashboard Page')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest Page')
        }
    })
}



async function main() {

    //   getUser()
    //     .then(user => {
    //         return login(user)
    //     })
    //     .then(status => {
    //         return showDashboard(status)
    //     }).then(page => {
    //         console.log(page)
    //     })
    //     .catch(err => console.log(err))

    try {
        const user = await getUser()
        const status = await login(user)
        const page = await showDashboard(status)
        console.log(user, status, page)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
....................................................................................
			  Module Pattern-ES 6 Modules
.....................................................................................
Module patterns
1.namespace design pattern
2.AMD
3.Commonjs
4.ES 6 Module pattern
5.System
6.UMD

COMMON JS and ES 6 only in dev..

How to share code from one file and folder?
 
There are two keywords

export, export default

How to link or import code from file and folder?

there is one keyword

import

eg:
src/util.js

export const firstName = 'Subramanian'
export const lastName = 'Murugan'

src/index.js
import { firstName, lastName } from "./util";

function main() {
    console.log(firstName, lastName)
}
main()

After running, you will get error

Uncaught SyntaxError: Cannot use import statement outside a module

the browsers dont support "es6 module pattern" directly.

How to run?

There are many ways

1.You can use build tools - webpack,rollup,vite etc...
2.YOu can use browser configurations


Using browser directly:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6 Apps</title>
</head>
<body>
    <h1>ES6 Apps</h1>
    <script  src="src/index.js" type="module"></script>
</body>
</html>

Second:
 while importing you must tell "fileName.js"

eg:
import { firstName, lastName } from "./util.js";

function main() {
    console.log(firstName, lastName)
}
main()
.........

export syntax:

// export const firstName = 'Subramanian'
// export const lastName = 'Murugan'
// export const address = {
//     city:'Coimbatore'
// }
// export const skills = ['react','android','ios']

const firstName = 'Subramanian'
const lastName = 'Murugan'
const address = {
    city: 'Coimbatore'
}
const skills = ['react', 'android', 'ios']

export { firstName, lastName, address, skills }


export default:
...............

src/App.js

// export default function AppOne() {
//     return 'App'
// }

export default function App() {
    return 'App'
}

src/index.js
import { firstName, lastName,skills,address } from "./util.js";
import App from "./App.js";

function main() {
    console.log(firstName, lastName,skills,address)
    console.log(App())
}
main()

export vs export default:

1.export can be used to export multiple things from single file
2.export default can be used to export only one thing from single file.


Can i coimbine export and export default in a single file?

 Yes!.

src/lib.js


export const version = '1.0'
export const name = 'Chat GPT '

export default class AIBot {
    constructor() {
        console.log('AIBOT')
    }
}
src/index.js
import { firstName, lastName, skills, address } from "./util.js";
import App from "./App.js";
import AIBot, { version, name } from "./lib.js";

function main() {
    console.log(firstName, lastName, skills, address)
    console.log(App())
    new AIBot()
    console.log(version, name)
}
main()


























