			 React/React.js
.....................................................................................

What is react?
   A JavaScript library for building user interfaces.

User interface apps are

1.Browser apps
2.Mobile apps
3.Desktop apps
4.Tv apps
5.etc...

React is used to build
 browser,mobile/tab ,tv.

.....................................................................................
			 Design patterns in UI Development
.....................................................................................
1.MVC
2.MVVM
3.Flux

React/React Native uses "Flux" design pattern

Flux is new design pattern to design ui invented by facebook.
 https://facebookarchive.github.io/flux/

https://facebookarchive.github.io/flux/docs/in-depth-overview

In Flux pattern react is "View/Ui/Presentation" Layer.

In Flux Pattern data is changed via "One directional Flow", You(UI) cant change data directly.
.....................................................................................
			 React and  Browser UI Development 
.....................................................................................

React in browser uses "HTML" as primary programming language for representing UI.
React in Mobile uses "Mobile specific language" for representing UI.
....................................................................................
			React and HTML
....................................................................................

DOM: - Document Object Model
............................
What is DOM?
   DOM is specification  released by W3c organgization,in order to build web apps for browsers.
https://www.w3.org/TR/1998/WD-DOM-19980416/		

In order to understand DOM fully , we need to understand HTML very deeply.

Programming language stages:
...........................

1.source code

hello.java
hello.c
hello.cpp
hello.py
hello.js

 ----->compiled ?

to generate assembly instructions

|
2.compiled code - assembly instruction
 hello.class
 hello.obj
|
3.Execute
 final output


HTML:

1.HTML IS PL? 
  - YES
2.HTML Is compiled 
  -YES
  HTML source code is compiled into assembly. 

3.HTML is executed?
  Yes

source code:

index.html

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>

|
-------------------Browser
loader---LOAD Code into browser
 |
  from file: or http:
 |
Parser :
   Parser is special compiler which converts source into lexcial tree(string tree)

body
  div
     h1
        Welcome 
     h1
  div
body

 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
|
.....................................................................................
				Runtime 
.....................................................................................
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList
body -Node
 div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body


 Linking the Nodes: Tree
body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
|
Layout/Paint Engine: will convert nodes into pxs : final output


sourcecode--->parsed code---compiled code---linked list---tree--->drawn on screen(ui)


.....................................................................................
         Static web pages: htmls are displayed into browser.
.....................................................................................
In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

			That is birth of javascript


How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.

.....................................................................................

............................................................................................

How dom works?

index.html           Browser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	       Every Html ELEMENT Inside javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.	

Architecture tech stack for dom programming


Plain JS
			 Application(dom) -plain js
			     |
			 Javascript Engine
			      |
			  Browser Engine

Framework/lib
			 Application(JQuery)
			     |
		       ---------------------------
			  JQuery Engine	------javascript programming		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine




Angular
			 Application(Angular)
			     |
		       ---------------------------
			  Angular Engine : Renderer(Ng2) Renderer2(Ng4,5),Ivy(6,7)		              -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine

React


		       Application(React)
			     |
		       ---------------------------
	             React Engine :React fiber-->React 16 on wards		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine
.....................................................................................

React can be used to build application for 

.........................................
1.browsers : Desktop
2.Mobile Apps : React Native

face book is working on many futures projects related to react

3.React VR : Virtual Reality.
4.React Car : For car applications
5.React TV (React Native)  : React for TV.
6.React IOT : any devices

We are going to learn react web for browsers.

React core modules:

react.js      => Core module
.................................

react-dom.js  => Browser
react-native.js => Mobile
.....................................................................................				React and ui building
...................................................................................

React uses  a small programming language to describe UI called "JSX"

As we discussed React is used in many app dev like browser,mobile,tv apps.

Each app type(browser,mobile) has its own JSX syntax(with respect to markup)...

Browser jsx uses HTML as language
Mobile Jsx uses "Mobile markup" as language.

-----------------------------------------------------------------------------
 Markup layer             |  React Core Engine    | Render Engine   | Target
-----------------------------------------------------------------------------

HTML Markup---------------|  Object Tree(V.DOM)   | ReactDom.render |  Browser

Mobile Markup-------------|  Object Tree          |ReactNative.render| Mobile 						   /Tabs/TV

..............
VR Markup---------------  |  Object Tree          |VR.render         |VR devices

IOT Markup--------------- |  Object Tree          | IOT.render       |IOT Devices   

.....................................................................................
			 React Project Setup
.....................................................................................

React teams offers tool set to create react projects


G:\IBM\2024\July\ReactNative-b2>npm create vite@latest
Need to install the following packages:
create-vite@5.4.0
Ok to proceed? (y) y


> npx
> create-vite

‚àö Project name: ... react-core
‚àö Select a framework: ¬ª React
‚àö Select a variant: ¬ª JavaScript

Scaffolding project in G:\IBM\2024\July\ReactNative-b2\react-core...

Done. Now run:

  cd react-core
  npm install
  npm run dev

....................................................................................
			How to create dom element using react
.....................................................................................

Exploring the project structure:

package.json
{
  "name": "my-react",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react": "^7.34.2",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.7",
    "vite": "^5.3.1"
  }
}

index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root">
	
   </div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


src/
 main.jsx

It is entry file/main program where we start.

//create dom element using plain js and how to attach on existing dom tree

function createElement() {
    const Heading = document.createElement('h1')
    Heading.innerHTML = 'Hello React!'
    //attach Heading with existing div
    const rootElement = document.getElementById('root')
    rootElement.appendChild(Heading)
}
createElement()
Using react:

import React from "react";
import ReactDOM from 'react-dom/client'

//CREATE DOM ELEMENT USING JSX
const Heading = <h1>Hello React!!</h1>// document.createElement('h1')

const rootElement = document.getElementById('root')
ReactDOM.createRoot(rootElement).render(Heading)

.....................................................................................
	JSX - java script and XML - langugage to create User interfaces
.....................................................................................

React uses declarative dom programing using a mini language invented by facebook : JSX

JSX : - javascript and xml

 1.PL language built by face book to write user interfaces.
 2.JSX is collection of html markup and javascript.
 3.JSX is dsl and declarative.
 4.Every device has its own jsx language syntax.
 5.Browsers jsx can't be used for building mobile application.


Since jsx  is a language cant be executed on browser /mobile directly.
..................................................................................

JSX compilation model:

                   layout.js / layout.jsx
		       |
		    compiler - babel.js 
			|
		    plain js code
			|-----------------------Dev cycle
	----------------------------------------- -- Excution cycles Starts
  Runtime : React Engine  compiled code feed into react engine
			|
		   Excute compiled js code : function calls
			|
	     create virtual Object tree (in browser V-dom)
		        |
	Render Engine ; will convert react object tree into js dom object tree/mobile
			|
		   Flush the tree into target
			|
	--------------------------------------------
        |      |
     Browser  Mobile


JSX is used to create dom elements/ Mobile elements

Every DOM element is object.

.....................................................................................
				Component
.................................................................................

What is Component ?
  Component is Object , Coined by MS in 1989.

According to ms, Component is object which has state(data),behaviour(methods) + User interface(Visual).
 eg:Button,TextBox,Grid,Menu,MenuBar,Layout,Table.....

Component === Widget ==== Object ==== DOM

Like Object tree(DOM Tree), In React we can create "Component" Tree.


      Node===DOM Object====Component
       h1     HTMLHeading   Heading

"React apps are made out of components. A Component is piece of the UI that has its own logic and appearance, A Component can be small as a button or as large as an entire Page"


.....................................................................................

			Component Creational patterns
...................................................................................


1.variable pattern
2.functional pattern
3.es 6 class pattern

Components can be created any one or mixed way  style.
"functional Pattern" is more popular and recommended pattern....


.....................................................................................

			Component Creational patterns
...................................................................................


1.variable pattern
2.functional pattern
3.es 6 class pattern

Components can be created any one or mixed way  style.
"functional Pattern" is more popular and recommended pattern....


1.Variable Pattern


import React from "react";
import ReactDOM from 'react-dom/client'

//Heading is just variable
//<h1>Hello React!!</h1> is Component
const Heading = <h1>Hello React!!</h1>// document.createElement('h1')

const rootElement = document.getElementById('root')
ReactDOM.createRoot(rootElement).render(Heading)



Functional Pattern:
...................
import ReactDOM from 'react-dom/client'

function Heading() {
    return <h1>
        Hello React!
    </h1>
}

ReactDOM.createRoot(document.getElementById('root')).render(Heading())

Here we are calling reader(Heading())

Heading() - calling function like this is not recommended - imperative programming

Heading() - function call can be converted html like syntax that means tag tax syntax. -<Heading></Heading>


import ReactDOM from 'react-dom/client'

function Heading() {
    return <h1>
        Hello React!
    </h1>
}

// ReactDOM.createRoot(document.getElementById('root')).render(Heading())
ReactDOM.createRoot(document.getElementById('root')).render(<Heading></Heading>)

Arrow functions and components:
...............................

import ReactDOM from 'react-dom/client'

// const Heading = () => {
//     return <h1>
//         Hello React!
//     </h1>
// }

const Heading = () => <h1>
    Hello React!
</h1>


ReactDOM.createRoot(document.getElementById('root')).render(<Heading></Heading>)
...................................................................................
			   class pattern

Now a days class pattern is almost deprecated, only functional pattern are popular..


import ReactDOM from 'react-dom/client'
import React  from 'react'

class Heading extends React.Component {

    //override render method from React.Component
    render(){
        return <h1>
            Hello React!!!
        </h1>
    }

}


ReactDOM.createRoot(document.getElementById('root')).render(<Heading></Heading>)

.....................................................................................
.....................................................................................
			Exploring JSX
.....................................................................................

JS-Javascript
X -  XML

Since HTML parser is weak, but when y write react code, we need consistent code generation.

So that react team, developed compiler follows basic xml rules.


Basic XML  rules:

1.every opened element must be closed
  <h1>Hello</h1>
  <Welcome></Welcome>
 some elements may not have closing tag
  <img /> : image element has no child elements : self closing.


eg:
import ReactDOM from 'react-dom/client'

const Welcome = ()=> {

    return <h1> Hello
}


ReactDOM.createRoot(document.getElementById('root')).render(<Welcome></Welcome>)

This code generates error.
................

The code which has no error.

import ReactDOM from 'react-dom/client'

const Welcome = ()=> {

    // return <h1> Hello
    return <h1> Hello</h1>
}


ReactDOM.createRoot(document.getElementById('root')).render(<Welcome/>)
.....................................................................................

2. In xml you must have one single root element.
  all elements must be organized under single root element.

   <h1>Welcome to IBM</h1>
   <p>Hello</p>

In html what can be root element
 <div>,<span>,all html 5 layout elements header,footer,section,aside...

			
const Welcome = ()=>{
    return <div>
        <h1>Hello
    </div>
}
This code will throw error.


import ReactDOM from 'react-dom/client'

const Welcome = () => {

    return <div>
        <h1>Welcome to IBM</h1>
        <p>Hello</p>
    </div>

}


ReactDOM.createRoot(document.getElementById('root')).render(<Welcome />)
....................................................................................
			  Fragments
....................................................................................

Some times i dont want root element but still i need to escape from compiler error
   -Fragements

Fragements are used to wrap elements invisible way.

Suppose if i dont want any root element, then we can use Fragement.

Fragements are used to escape from compiler.


Syntax:

1. <React.Fragment>

 </React.Fragement>

2. <Fragment>

 </Fragement>


3.<>

 </>


import ReactDOM from 'react-dom/client'
// import React, { Fragment } from 'react'

// const Welcome = () => {
//     return <React.Fragment>
//         <h1>Welcome to IBM</h1>
//         <p>Hello</p>
//     </React.Fragment>

// }


// const Welcome = () => {
//     return <Fragment>
//         <h1>Welcome to IBM</h1>
//         <p>Hello</p>
//     </Fragment>

// }
const Welcome = () => {
    return <>
        <h1>Welcome to IBM</h1>
        <p>Hello</p>
    </>

}


ReactDOM.createRoot(document.getElementById('root')).render(<Welcome />)




Component Name :

import ReactDOM from 'react-dom/client'

const heading = () => {

    return <>
        <h1>Welcome to IBM</h1>
        <p>Hello</p>
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(<heading/>)



chunk-373CG7ZK.js?v=98769346:519 Warning: The tag <heading> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.
    at heading

..................................................................................
			..................................................................................
			Component Composition
..................................................................................

I have ui called gallery, inside Gallary i want to display Profile information.

Level - 1:
import ReactDOM from 'react-dom/client'

const Gallery = () => {
    return <div>
        <h1>Scientists / Computer</h1>
        <h3>Alan Turing</h3>
        <h4>Born : 23 June 1912</h4>
        <h4>Died : 7 June 1954 (aged 41)
            Wilmslow, Cheshire, England
        </h4>
    </div>
}


ReactDOM.createRoot(document.getElementById('root')).render(<Gallery />)

Here scientists information is tightly coupled with Gallery.

import ReactDOM from 'react-dom/client'

const ProfileHeading = () => <h1>Scientists / Computer</h1>

const Profile = () => {
    return <>
        <ProfileHeading />
        <h3>Alan Turing</h3>
        <h4>Born : 23 June 1912</h4>
        <h4>Died : 7 June 1954 (aged 41)
            Wilmslow, Cheshire, England
        </h4>
    </>
}

const Gallery = () => {
    return <div>
        <Profile />
    </div>
}


ReactDOM.createRoot(document.getElementById('root')).render(<Gallery />)
.....................................................................................
.....................................................................................
.....................................................................................
			 React Dev tool
.....................................................................................

It is tool part of browser as plugin, used to insepect the structure of app.
https://react.dev/learn/react-developer-tools

.....................................................................................
.....................................................................................
		  Component Composition and Modularity
.....................................................................................
Every Component will go into separate folders and files, through es 6 modules you can 
https://legacy.reactjs.org/docs/faq-structure.html

import export components..

src/profile/Profile.jsx

import { ProfileHeading } from "./ProfileHeading"

const Profile = () => {
    return <>
        <ProfileHeading />
        <h3>Alan Turing</h3>
        <h4>Born : 23 June 1912</h4>
        <h4>Died : 7 June 1954 (aged 41)
            Wilmslow, Cheshire, England
        </h4>
    </>
}
export { Profile }


src/gallery/Gallery.jsx

import { Profile } from "../profile/Profile"

const Gallery = () => {
    return <div>
        <Profile />
    </div>
}
export { Gallery } 


src/App.jsx
import { Gallery } from "./gallery/Gallery"

function App() {

  return (
    <>
      <Gallery />
    </>
  )
}

export default App


src/main.jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
..................................................................................
			Barrel Export
..................................................................................

src/welcome/
   Hello.jsx
   Hai.jsx
   Greeter.jsx

when you import these files where ever, we have to import 
		 
import { Hello } from "./welcome/Hello"
import { Hai } from "./welcome/Hai"
import { Greeter } from "./welcome/Greeter"

Barrel export is nothing simplifiying export and import...
 Using Barrel export you dont need to use fileName when import
 Using Barrel export you dont need to use multiple import statement.

How to use barrel export?

Rule 1:
 inside folder create "index.js"
 src/profile/index.js 

Rule 2:
 inside index.js
  
 import {Profile} './Profile'

 export {Profile}

Rule 3: 
  inside another file like gallary.jsx

  import {Profile} './profile'

.....................................................................................
			 Data binding


Data can be string,number,boolean,object,array

{Variable} | {expression} | {value}

import React from 'react'
import ReactDOM from 'react-dom/client'

const Profile = () => {

  const name = 'Alan Turing'
  const birthdate = '23 June 1912'

  return <div>
    <h1>{name}</h1>
    <h2>born:{birthdate}</h2>
  </div>
}

const App = () => {
  return <>
    <Profile />
  </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
..................................................................................
			   Data Binding Patterns

1.property binding aka props pattern
2.State binding aka state pattern.


props Pattern:

When you think about component , you should thing about resuablity..

How to create component with resuablity?

 Component should be configurable, Component should accept data from outside.

if data is passed to the component from outside(From another component -Parent),
This pattern is called props pattern /Property pattern.

Since Component is function, function can take args (which is called property).


import React from 'react'
import ReactDOM from 'react-dom/client'

const Profile = (name,birthdate) => {
    return <div>
        <h1>{name}</h1>
        <h2>born:{birthdate}</h2>
    </div>
}

const App = () => {
    return <>
        {/* <Profile /> */}
        {Profile('Alan Turing','23 June 1912')}
        {Profile('Alonzo Church','June 14, 1903')}
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

props:
import React from 'react'
import ReactDOM from 'react-dom/client'

//props = {name:'x',birthdate:''}
const Profile = (props) => {
    return <div>
        <h1>{props.name}</h1>
        <h2>born:{props.birthdate}</h2>
    </div>
}

const App = () => {
    return <>
        <Profile name='Alan Turing' birthdate={'23 June 1912'}  />
        <Profile name='Alonzo Church' birthdate={'June 14, 1903'} />
        {/* {Profile('Alan Turing','23 June 1912')}
        {Profile('Alonzo Church','June 14, 1903')} */}
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

Passing more data:
import React from 'react'
import ReactDOM from 'react-dom/client'

//props = {name:'x',birthdate:''}
const Profile = (props) => {
    return <div>
        <h1>{props.name}</h1>
        <h2>born:{props.birthdate}</h2>
        <h2>Alive: {props.isAlive ? "Alive" : "No More"}</h2>
        <h3>Rating: {props.rating}</h3>
    </div>
}

const App = () => {
    const isAlive = false

    return <>
        {/* {name:'',birthdate:} */}
        <Profile name='Alan Turing' birthdate={'23 June 1912'} isAlive={false} rating={9} />
        <Profile name='Alonzo Church' birthdate={'June 14, 1903'} isAlive={isAlive} rating={8} />
        {/* {Profile('Alan Turing','23 June 1912')}
        {Profile('Alonzo Church','June 14, 1903')} */}
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

How to break down into another component and pass data?

import React from 'react'
import ReactDOM from 'react-dom/client'

const Avatar = props => <img src={props.src} alt="Name" width={100} height={100} />

const Profile = (props) => {
    return <div>
        <Avatar src={props.src} />
        <h1>{props.name}</h1>
        <h2>born:{props.birthdate}</h2>
        <h2>Alive: {props.isAlive ? "Alive" : "No More"}</h2>
        <h3>Rating: {props.rating}</h3>
    </div>
}

const App = () => {
    const isAlive = false
    const imageSrc = 'https://i.imgur.com/1bX5QH6.jpg'
    return <>
        {/* {name:'',birthdate:} */}
        <Profile src={imageSrc} name='Alan Turing' birthdate={'23 June 1912'} isAlive={false} rating={9} />
        <Profile src={imageSrc} name='Alonzo Church' birthdate={'June 14, 1903'} isAlive={isAlive} rating={8} />
        {/* {Profile('Alan Turing','23 June 1912')}
        {Profile('Alonzo Church','June 14, 1903')} */}
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
..................................................................................
			  Props and Object descturing
..............................................................................
import React from 'react'
import ReactDOM from 'react-dom/client'

const Avatar = ({ src }) => <img src={src} alt="Name" width={100} height={100} />

// const Profile = (props) => {
//     const { src, name, isAlive, rating,birthdate } = props
//     return <div>
//         <Avatar src={src} />
//         <h1>{name}</h1>
//         <h2>born:{birthdate}</h2>
//         <h2>Alive: {isAlive ? "Alive" : "No More"}</h2>
//         <h3>Rating: {rating}</h3>
//     </div>
// }

const Profile = ({ src, name, isAlive, rating, birthdate }) => <div>
    <Avatar src={src} />
    <h1>{name}</h1>
    <h2>born:{birthdate}</h2>
    <h2>Alive: {isAlive ? "Alive" : "No More"}</h2>
    <h3>Rating: {rating}</h3>
</div>



const App = () => {
    const isAlive = false
    const imageSrc = 'https://i.imgur.com/1bX5QH6.jpg'
    return <>
        <Profile src={imageSrc} name='Alan Turing' birthdate={'23 June 1912'} isAlive={false} rating={9} />
        <Profile src={imageSrc} name='Alonzo Church' birthdate={'June 14, 1903'} isAlive={isAlive} rating={8} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
....................................................................................
			 Default values and Props
....................................................................................

import React from 'react'
import ReactDOM from 'react-dom/client'

const Avatar = ({ src }) => <img src={src} alt="Name" width={100} height={100} />

const Profile = ({ src = 'https://i.imgur.com/1bX5QH6.jpg', name = 'Your Name', isAlive = false, rating = 0, birthdate = '01 Jan 1950' }) => <div>
    <Avatar src={src} />
    <h1>{name}</h1>
    <h2>born:{birthdate}</h2>
    <h2>Alive: {isAlive ? "Alive" : "No More"}</h2>
    <h3>Rating: {rating}</h3>
</div>

//old way:
// Profile.defaultProps = {
//     src: "https://i.imgur.com/1bX5QH6.jpg",
//     name: 'Your Name',
//     birthdate: '01 Jan 1950',
//     isAlive: false,
//     rating:0
// }


const App = () => {
    const isAlive = false
    const imageSrc = 'https://i.imgur.com/1bX5QH6.jpg'
    return <>
        {/* <Profile src={imageSrc} name='Alan Turing' birthdate={'23 June 1912'} isAlive={false} rating={9} />
        <Profile src={imageSrc} name='Alonzo Church' birthdate={'June 14, 1903'} isAlive={isAlive} rating={8} /> */}
        <Profile />
        <Profile src={imageSrc} name='Alan Turing' birthdate={'23 June 1912'} isAlive={false} rating={9} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
...................................................................................
		Forwarding props with JSX Spread Notation
.....................................................................................
import ReactDOM from 'react-dom/client'
import React from 'react'

const Avatar = ({ title = "", src = 'https://i.imgur.com/1bX5QH6.jpg', name = 'Your Name', isAlive = false, rating = 0, birthdate = '01 Jan 1950' }) => <>
    <h1>{title}</h1>
    <img src={src} alt="Name" width={100} height={100} />
    <h1>{name}</h1>
    <h2>born:{birthdate}</h2>
    <h2>Alive: {isAlive ? "Alive" : "No More"}</h2>
    <h3>Rating: {rating}</h3>
</>
const Profile = props => <div>
    {/* <Avatar src={props.src} name={props.name} isAlive={props.isAlive} birthdate={props.birthdate} rating={props.rating} /> */}
    {/* We can pass props simply using spread notation (...) */}
    <Avatar {...props} title="Most Popular People" />
</div>

const App = () => {
    const isAlive = false
    const imageSrc = 'https://i.imgur.com/1bX5QH6.jpg'
    return <>
        <Profile />
        <Profile src={imageSrc} name='Alan Turing' birthdate={'23 June 1912'} isAlive={false} rating={9} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
			  List Rendering
.....................................................................................


Simple List:
import ReactDOM from 'react-dom/client'
import React from 'react'


const List = props => {

   const { names } = props
    return <>
        <ul>
            {names.map(name => {
                return <li>{name}</li>
            })}
        </ul>
    </>
}



const App = () => {
    const names = ['Subramanian', 'Murugan', 'Chandrasekar', 'Percy', 'Alan Turing']
    return <>
        <List names={names} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

Complex List:

import ReactDOM from 'react-dom/client'
import React from 'react'
import { PRODUCTS } from './mock-data/product'

const ProductList = props => {

    const { products } = props
    return <div>
        {
            products.map(product => {
                return <section key={product.id}>
                    <h1>{product.id}</h1>
                    <h3>{product.title}</h3>
                    <div>
                        {product.images.map((img,index) => {
                            return <img key={index} src={img} height={100} width={100} alt='img' />
                        })}
                    </div>
                <h4>Price : {product.price}</h4>
                </section>
            })
        }
    </div>
}



const App = () => {
    return <>
        <ProductList products={PRODUCTS} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
...................................................................................
				Filtering data

import ReactDOM from 'react-dom/client'
import React from 'react'
import { PRODUCTS } from './mock-data/product'

const ProductList = props => {

    const { products } = props

    const filteredProducts = products.filter(product => {
        return product.price > 50
    })

    return <div>
        {
            filteredProducts.map(product => {
                return <section key={product.id}>
                    <h1>{product.id}</h1>
                    <h3>{product.title}</h3>
                    <div>
                        {product.images.map((img, index) => {
                            return <img key={index} src={img} height={100} width={100} alt='img' />
                        })}
                    </div>
                    <h4>Price : {product.price}</h4>
                </section>
            })
        }
    </div>
}



const App = () => {
    return <>
        <ProductList products={PRODUCTS} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
				Styling
.....................................................................................
CSS 

What is CSS?
 language - Styling language - DSL and declarative
 to design web pages


using css language directly -  css selectors
<h1 class="selector">

inline style
<h1 style="color:red">
 -static css

using css via javascript
  - dynamic css

<h1 id="heading">hello</h1>

let heading= document.getElementById("heading")
heading.style.color='red'
//text-align: center;
heading.style.textAlign='center'

import ReactDOM from 'react-dom/client'
import React from 'react'
import { PRODUCTS } from './mock-data/product'
import './index.css'

const ProductList = props => {

    const { products } = props

    const filteredProducts = products.filter(product => {
        return product.price > 50
    })

    return <div>
        {
            filteredProducts.map(product => {
                return <section key={product.id} className="card" >
                    <h1 style={styles.heading}>{product.id}</h1>
                    <h3 style={{color:'green'}}>{product.title}</h3>
                    <div>
                        {product.images.map((img, index) => {
                            return <img key={index} src={img} height={100} width={100} alt='img' />
                        })}
                    </div>
                    <h4>Price : {product.price}</h4>
                </section>
            })
        }
    </div>
}

//style object
const styles = {
    heading: {
        color: 'blue',
        borderRadius: 8,
        border: 1,
        boxShadow:"10px 20px 30px blue"
    }
}



const App = () => {

    return <>
        <ProductList products={PRODUCTS} />
    </>
}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
....................................................................................
....................................................................................
			Conditional Rendering
....................................................................................
How to introduce if ...else and also tenary operator in jsx?

Your components will often need to display different things depending on different conditions.

In React, you can conditionally render jsx using javascript syntax like if statement ,&& and ?: operator..

Returning different JSX(Component) depending on condition.


Use case : using if..else how to render components

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

const todoList = [{
    id: 1,
    name: 'learn react',
    status: true
},
{
    id: 2,
    name: 'Learn next',
    status: false
},
{
    id: 3,
    name: 'learn es',
    status: true
},
{
    id: 4,
    name: 'learn Angular',
    status: false
},
{
    id: 5,
    name: 'learn React Native',
    status: false
}

]

const Item = props => {
    const { name, status } = props.todo
    //using if condition
    if (status) {
        return <li>{name} ‚úî</li>
    } else {
        return <li>{name} X </li>
    }
}
const TodoList = props => {
    return <>
        <ul>
            {
                props.todos.map(todo => {
                    return <>
                        <Item todo={todo} />
                    </>
                })
            }
        </ul>
    </>
}
const App = () => {
    return <>
        <TodoList todos={todoList} />
    </>

}



ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

Use case: COnditional rendering using Tenary Operator

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

const todoList = [{
    id: 1,
    name: 'learn react',
    status: true
},
{
    id: 2,
    name: 'Learn next',
    status: false
},
{
    id: 3,
    name: 'learn es',
    status: true
},
{
    id: 4,
    name: 'learn Angular',
    status: false
},
{
    id: 5,
    name: 'learn React Native',
    status: false
}

]

// const Item = props => {
//     const { name, status } = props.todo
//     //using Tenary Operator
//     return status ? <li>{name} ‚úî</li> : <li>{name} X </li>
// }

const Item = ({ todo: { name, status } }) => status ? <li>{name} ‚úî</li> : <li>{name} X </li>

const TodoList = props => {
    return <>
        <ul>
            {
                props.todos.map(todo => {
                    return <>
                        <Item todo={todo} />
                    </>
                })
            }
        </ul>
    </>
}
const App = () => {
    return <>
        <TodoList todos={todoList} />
    </>

}



ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

Use case: Conditional Rendering using && Operator:

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

const todoList = [{
    id: 1,
    name: 'learn react',
    status: true
},
{
    id: 2,
    name: 'Learn next',
    status: false
},
{
    id: 3,
    name: 'learn es',
    status: true
},
{
    id: 4,
    name: 'learn Angular',
    status: false
},
{
    id: 5,
    name: 'learn React Native',
    status: false
}

]


// const Item = ({ todo: { name, status } }) => status ? <li>{name} ‚úî</li> : <li>{name} X </li>

const Item = ({ todo: { name, status } }) => <li> {name} {status && '‚úî'}</li>

const TodoList = props => {
    return <>
        <ul>
            {
                props.todos.map(todo => {
                    return <>
                        <Item todo={todo} />
                    </>
                })
            }
        </ul>
    </>
}
const App = () => {
    return <>
        <TodoList todos={todoList} />
    </>

}


ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
				What can be prop
.....................................................................................

1.Prop can be data
2.Prop can another component or element
..
3.Prop can be function
4.Prop can be state(dynamic prop)



1.Prop can be another component or element.

How to render component

 <Grid></Grid> -  Grid can have children: passing prop
 <Grid/> -  Grid has no children
 
Parent-Child Relation ship:

cont A = ()=>{
  return <B/>
}
Parent-Child Relation ship:
 via props

<Layout> -parent
	<Page>-child
		<Header> -child
		   <Logo> -child

		   </Image>
		</Header>
	</Page>
</Layout>  

.....................................................................................
			Component as Prop

.....................................................................................

Use case : Without component as prop.

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

const Page = () => {
    return <h1>Page</h1>
}
const Header = () => {
    return <h1>Header</h1>
}
const Footer = () => {
    return <h1>Footer</h1>
}
const Layout = () => {
    return <div>
        <Header />
        <Page />
        <Footer />
    </div>
}

const App = () => {
    return <>
        <Layout />
    </>

}



ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

Use case : with Props:
......................
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { PRODUCTS } from './mock-data/product'

const ProductList = props => {

    const { products } = props
    return <div>
        {
            products.map(product => {
                return <section key={product.id}>
                    <h1>{product.id}</h1>
                    <h3>{product.title}</h3>
                    <div>
                        {product.images.map((img, index) => {
                            return <img key={index} src={img} height={100} width={100} alt='img' />
                        })}
                    </div>
                    <h4>Price : {product.price}</h4>
                </section>
            })
        }
    </div>
}

const Page = ({ children }) => {
    return <div>
        {children}
    </div>
}
const Header = (props) => {
    return <>
        <>{props.children}</>
        <hr />
    </>
}
const Footer = () => {
    return <h1>Footer</h1>
}
const Layout = (props) => {
    return <div>
        {props.children}
    </div>
}

const App = () => {
    return <>
        <Layout>
            {/* Passing these components as prop */}
            <Header>
                <h1>IBM</h1>
            </Header>
            <Page>
                <ProductList products={PRODUCTS} />
            </Page>
            <Footer />
        </Layout>
    </>

}



ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
..................................................................................
...................................................................................
			   State Pattern
		       (Dynamic User Interface)
			 (Event Handling)
....................................................................................

What is state?
  State is another way of representing data in React.

As of we have seen data is not changing or updating...

How to introduce State?

There are two ways

1.class pattern 
   It is legacy way of representing state and Managining state
   It is not recommended..

2.Function pattern
    It is modern way of representing state
    State is represented via "Hook".


1.class pattern 

Declare class:
import React from 'react';
import ReactDOM from 'react-dom';


class Review extends React.Component {

    render() {
        return <div>
            <h1>Review Component</h1>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);
..................................................................................
Declare data:

React.Component is super class , which is having properites and methods

Methods:

1.lifecycle methods
2.setState
3.forceUpdate()

Instance Properties

1.state
2.props

state default value is null, that means we need to initalize state variable with data.

import React from 'react';
import ReactDOM from 'react-dom/client';


class Review extends React.Component {

    render() {
        console.log(this.state)
        return <div>
            <h1>Review Component</h1>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);

here out put would be "null"

...

How to declare state?

import React from 'react';
import ReactDOM from 'react-dom/client';


class Review extends React.Component {

    //state declaration
    state = {
        //application data/ui data
        like: 0
    }

    render() {
        console.log(this.state)
        return <div>
            <h1>Review Component</h1>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);
..............
How to bind state in UI, what is initial state.

Initial state means, the state(data) is associated with UI during first rendering.

import React from 'react';
import ReactDOM from 'react-dom/client';


class Review extends React.Component {

    //state declaration
    state = {
        //application data/ui data
        like: 10
    }

    render() {
        console.log(this.state)
        return <div>
            <h1>Review Component</h1>
            <h5>Like {this.state.like}</h5>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);

....................................................................................
			  Event Handler
....................................................................................
import React from 'react';
import ReactDOM from 'react-dom/client';


class Review extends React.Component {

    //state declaration
    state = {
        //application data/ui data
        like: 10
    }
    //listener: arrow function
    onLike = () => {
        console.log('like')
    }
    render() {
        console.log(this.state)
        return <div>
            <h1>Review Component</h1>
            <h5>Like {this.state.like}</h5>
            <button onClick={this.onLike}>üòÅ</button>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);
.....................................................................................
		    State Mutation -State update/change
...................................................................................
			 State Mutation
..................................................................................

How Component can change the data?

-Via State

How state can be changed

-Via Events


import React from 'react';
import ReactDOM from 'react-dom/client';


class Review extends React.Component {

    //state declaration
    state = {
        //application data/ui data
        like: 10
    }
    //listener: arrow function
    onLike = () => {
        this.state.like++
        console.log('inside listener', this.state)
    }
    render() {
        console.log('inside render', this.state)
        return <div>
            <h1>Review Component</h1>
            <h5>Like {this.state.like}</h5>
            <button onClick={this.onLike}>üòÅ</button>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);

In the above we have incremented, like inside listener, but no update in UI

Why?
  
  UI logic is written inside render function,
  When ever like is changed, we need to call render function, so that ui could be updated with new like data.

How to call render?

import React from 'react';
import ReactDOM from 'react-dom/client';


class Review extends React.Component {

    //state declaration
    state = {
        //application data/ui data
        like: 10
    }
    //listener: arrow function
    onLike = () => {
        this.state.like++
        console.log('inside listener', this.state)
        //calling render
        this.render()
    }
    render() {
        console.log('inside render', this.state)
        return <div>
            <h1>Review Component</h1>
            <h5>Like {this.state.like}</h5>
            <button onClick={this.onLike}>üòÅ</button>
        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);

You can notice in the above, we have called render inside listener, render is called but no UI update.

Why?

Can we call render method directly inside event listener...
Yes, but no impact on ui update...

   onLike = () => {
        this.state.like++
        console.log(this.state.like)
        this.render()
        console.log('onLike is clicked')
    }
Note: render should be not called directly in order to update user interface..
....................................................................................

.................................................................................
		Before writing code, we need to learn the concept
....................................................................................
			Functional Programming principles
....................................................................................
Programming paradigms:
 any programming language is built on the top of programming paradigms
 Collections of set of principles and concepts.

Most popular programming paradigms.
1.Object oriented
   C++,java,C#......
2.Procedural oriented
   C
3.Functional Programming 
   LISP,Clojure,scheme,js

Some languages follow multiple paradigms (hybrid) , some follow single paradigm (solo)

javascript is object based, functional style programming language.
java is object oriented,functional style programming...

What is functional programming?

  It is type of programming paradigm.

functional programming is the first programming paradagim introduced in 1935, as part of Mathmetics called "Lambda Calculs".

The first functional programming language called "LISP" was created in 1955.

React uses fp principles:

1.Pure functions
2.Immuablity


Pure Functions:

Pure functions are defined by two rules..

Rule A:
  if function receives input, the function returns the input without any mutation...

//fp principles : rule A:


//is this function is pure or not : pure 
function Hello(message) {
    return message
}
console.log(Hello('hello'))

//is this function is pure or not: impure function
function doubleIt(value) {
    return value * 2
}
console.log(doubleIt(20))

Are we applying pure function rule a in React?


Yes,With Respect to "props" every function is pure.

//Pure function rule A in react.
import ReactDOM from 'react-dom/client';

//Every component is  based on pure function with respect to "props"
const Welcome = props => {
    //props.message = 'hai' // props are read only
     return <div>
        <h1>{props.message}</h1>
    </div>
}

const App = () => {
    return <>
        <Welcome message="hello" />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
.....................................................................................
				Pure Function Rule B
....................................................................................
Rule B:
.......
 if function receives input, what if i want to change(mutate),We can apply rule b.
 
if function receives input,and modify input , we should return new object every time, which is called immutablity.
 



//pure function Rule B


function updateProfile(city, profile) {
    //update profile city 
    profile.city = city
 
    return profile
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

Result:
before update {name: 'Subramanian', city: 'Coimbatore'}
index.js:18 Same Object
index.js:19 after update {name: 'Subramanian', city: 'Chennai'}

The above code is pure or not?

The above is not pure, it is impure.

 "I need to mutate state(data), but at the same time, i need purity"
			
	                  Apply Immutablity Principle


What is immutability?

  When ever you update the data(object), you have to create new object every time.

In order to write immutable code, js supports many patterns

1. Plain js pattern.
//pure function Rule B

function updateProfile(city, profile) {
    //return new object
    return {
        name: profile.name,
        city: city
    }
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

Plain js pattern has some drawback, we have to copy all the properties manually...

2.Object.assign pattern
//pure function Rule B

function updateProfile(city, profile) {
    //Object.assign 
    return Object.assign({}, profile, { city: city })
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

3.ES 7 Spread operator 
//pure function Rule B

function updateProfile(city, profile) {
      return { ...profile, city }
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

.....................................................................................
.....................................................................................
			Arrays -Pure functions (immutablity)
.....................................................................................

Array pure functions:

1.map
  map is pure function , which returns new array when you iterate.

2.filter
  filter is also function, which returns new array when you iterate.

map:


function transform(data) {

    return data.map(item => item)
}

let list = ['subramanian', 'ram', 'murugan']

const response = transform(list)

console.log(list === response ? "Same" : "Different")

filter:


function filter(data) {

    return data.filter(item => item.status === true)
}

let employees = [{
    id: 1,
    name: 'subramanian',
    status: true
},
{
    id: 2,
    name: 'Ram',
    status: false
},
{
    id: 3,
    name: 'Karthik',
    status: true
},
{
    id: 4,
    name: 'Murugan',
    status: false
}

]

const response = filter(employees)

console.log(employees === response ? "Same" : "Different")
.....................................................................................

Add Item:

push


//is it pure or not
function add(todos, todo) {
    return todos.push(todo)
}
let todos = [{
    title: 'Learn react',
    done: true
}];

//Testing 
Object.freeze(todos)

console.log(add(todos, { title: 'Learn Microservices', done: false }));


Response:
Uncaught TypeError: Cannot add property 1, object is not extensible

You are trying to add  on exiting memory... which is not pure and immutable...

so "array.push" is not pure function.

How to add item into array with purity:

Solution:

1.concat
   it is pure and immutable method..

//is it pure or not
function add(todos, todo) {
   // return todos.push(todo)
   return todos.concat(todo)
}
let todos = [{
    title: 'Learn react',
    done: true
}];

//Testing 
Object.freeze(todos)

console.log(add(todos, { title: 'Learn Microservices', done: false }));

2.Using spread operator

//is it pure or not
function add(todos, todo) {
    // return todos.push(todo)
    //  return todos.concat(todo)
    return [...todos, todo]
}
let todos = [{
    title: 'Learn react',
    done: true
}];

//Testing 
Object.freeze(todos)

console.log(add(todos, { title: 'Learn Microservices', done: false }));
....................................................................................
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

class Like extends React.Component {

    state = {
        value: 0
    }
    //Event Listener
    onIncrement = () => {
        //through pure function only we can mutate the state
        //prevState is just variable holding "State Object"
        this.setState((prevState) => {
            //return immutable object
            // return {
            //     value: prevState.value+1
            // }
            // return Object.assign({}, prevState, { value: prevState.value + 1 })
            return { ...prevState, value: prevState.value + 1 }
        })
    }

    render() {
        console.log(this.state)
        const { value } = this.state
        return <div>
            {/* <h1>Like {this.state.value}</h1> */}
            <h1>Like {value}</h1>
            <button onClick={this.onIncrement}>Like</button>
        </div>
    }
}



const App = () => {
    return <>
        <Like />
    </>

}



ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
.....................................................................................
			Multiple State and Inline Event Listener
.....................................................................................

Note :
 if want to more state variables, that has to be enclosed within single object only

 state = {
  ....
 }
import React from 'react';
import ReactDOM from 'react-dom/client';

class Review extends React.Component {

    state = {
        like: 10,
        dislike: 10
    }
    onLike = () => {
        this.setState(function (previousState) {
            console.log('Previous State ', previousState)
            return { ...previousState, like: previousState.like + 1 }
        })
    }
    render() {
        console.log('current state', this.state)
        return <div>
            <h1>Review Component</h1>
            <h5>Like {this.state.like} Dislike {this.state.dislike}</h5>
            <button onClick={this.onLike}>üòÅ</button>
            {/* Inline listener */}
            <button onClick={() => {
                this.setState(function (previousState) {
                    console.log('Previous State ', previousState)
                    return { ...previousState, dislike: previousState.dislike + 1 }
                })
            }}>üò´</button>

        </div>
    }
}


const App = () => {
    return <>
        <Review></Review>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);
.....................................................................................
.....................................................................................
			Complex State :Nested State

			   
state= {
   house:{
     name:'RavenClaw',
     points:10
   }
}

I need to increase the points By two..

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'

class HouseRating extends React.Component {
    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }
    onIncreasePointsByTwo = () => {
        this.setState((prveState)=>{
            return {
                ...prveState,  //level -0 copy
                 house: {
                    ...prveState.house, // level-1 copy : copy all properties within house 
                    points: prveState.house.points+ 2
                 }
            }
        })
    }

    render() {
        return <div>
            <h1>House Rating Component</h1>
            <h3>House Name : {this.state.house.name}</h3>
            <h3>Points : {this.state.house.points}</h3>
            <button onClick={this.onIncreasePointsByTwo}>+</button>
        </div>
    }
}

const App = () => {
    return <>
        <HouseRating />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);

.....................................................................................
				Deep Nesting
.....................................................................................

Assigment:
state = {
  customer: {
    id:1,
    name:'Subramanian'
    contact: {
	address: {
	    city:'Chennai'
	},
	communcation:{ 
           mobileNo:'9000000'
	}
    }
  }

}

How to update mobileNo - 834343434
.....................................................................................
		      Complxity of Immutable Objects 
				 and 
			How to solve  them using 
			     immer.js
.....................................................................................
What is immer?
  immer is simple js lib, which helps to write complex immutable code in "mutable way" like regular javascript way.

immutable syntax to update object property:

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }

     return {
                ...prevState, //level -0 copy
                house: {
                    ...prevState.house, // level-1 copy
                    points: prevState.house.points + 2
                }
        }

js syntax:

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }

update state:

state.house.points +=2

immer is lib which takes care of writing immutable code on behalf of us, developer writes mutable code, immer converts into immutable code.

Immer core concept:

immer provides a function called "produce"

produce(state,(draft)=>{
  draft.house.points +=2
})

Getting started:

steps:

1.install immer lib

npm i immer

import React from 'react';
import ReactDOM from 'react-dom/client';
import { produce } from 'immer';
import './index.css'

class HouseRating extends React.Component {

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }
    onIncreasePointsByTwo = () => {
        this.setState((prevState) => {
            return produce(prevState, (draft) => {
                draft.house.points += 2
            })

        })
    }
    render() {
        return <div>
            <h1>House Rating Component</h1>
            <h3>House Name : {this.state.house.name}</h3>
            <h3>Points : {this.state.house.points}</h3>
            <button onClick={this.onIncreasePointsByTwo}>Rate</button>
        </div>
    }
}


const App = () => {
    return <>
        <HouseRating />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
import React from 'react';
import ReactDOM from 'react-dom/client';
import { produce } from 'immer';
import './index.css'

class HouseRating extends React.Component {

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }
    onIncreasePointsByTwo = () => {
        this.setState((prevState) => {
            return produce(prevState, (draft) => {
                draft.house.points += 2
            })

        })
    }
    render() {
        return <>
            {/* here state as prop(dynamic prop) and function as prop */}
            <HouseRatingDashBoard {...this.state} onIncrement={this.onIncreasePointsByTwo} />
        </>
    }
}

const HouseRatingDashBoard = props => {
    console.log
    return <div>
        <h1>House Rating Component</h1>
        <h3>House Name : {props.house.name}</h3>
        <h3>Points : {props.house.points}</h3>
        <button onClick={props.onIncrement}>Rate</button> 
    </div>
}


const App = () => {
    return <>
        <HouseRating />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
.....................................................................................
			State as prop, function as Prop
.

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { produce } from 'immer'

class Review extends React.Component {

    //nested state
    state = {
        movie: {
            name: ' Atlas',
            like: 0,
            dislike: 0
        },
        actor: {
            name: 'Jennifer Lopez'
        }
    }
    onLike = () => {
        this.setState(prevState => {
            return produce(prevState, (draft) => {
                draft.movie.like += 1
            })
        })
    }
    onDislike = () => {
        this.setState(prevState => {
            return produce(prevState, (draft) => {
                draft.movie.dislike += 1
            })
        })
    }
    render() {
        return <div>
            {/* state as prop and function as prop */}
            <ReviewDashboard  {...this.state} onLike={this.onLike} onDislike={this.onDislike} />
        </div>
    }
}

const ReviewDashboard = ({ movie: { name, like, dislike }, actor, onLike, onDislike }) => {
    return <>
        <h1>Movie Reviews</h1>
        <h2>Name: {name} </h2>
        <h2>Actresses {actor.name}</h2>
        <h3>Like : {like} Dislike {dislike}</h3>
        <button onClick={onLike}>Like</button>
        <button onClick={onDislike}>Dislike</button>
    </>
}

const App = () => {
    return <div>
        <Review />
    </div>

}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
....................................................................................
			 Component Life cycles
.....................................................................................

React Component life cycle can be classified into three major phases

1.Mount

2.Update

3.UnMount

1.Mount :
  Incase of class component

 1.constructor
     Called only once in the component initalization
     constructors are not used very much...
 2.render
    Called for creating object tree-component tree-Virtual DOM

 3.componentDidMount
    Called after render method, once the dom is ready- once ui is compltly loaded

    This method is used heavily  used in react all versions.

   It is used to inital data fetching from the apis
   It is used to write any async task
   It is used to write websocket connections


2.Update
    When user starts interacting
   when state is mutated  -setState,forceUpdate
   when new props are supplied -state as prop
  
   render
      method is called after state mutation, in order to update ui with new state/
   during render call,it creates vdom, apply an algorthim called "diff", to compute    old tree and new tree, update dom accordingly.
  
   componentDidUpdate
     It is method which is called after render is completed in update cycle.
    incase if you want fetch data from api after dom updates
    incase if you want to do any async tasks.
    
3.UnMount
  When component is removed from memory
 ComponentWillunMount
   any resource clean up task...

import { produce } from 'immer';
import React from 'react';
import ReactDOM from 'react-dom/client';


class Counter extends React.Component {
    state = {
        value: 0
    }
    constructor() {
        super()
        console.log('constrcutor is called')
    }
    //render
    render() {
        console.log('render is called')
        return <>
            <h1>Counter {this.state.value} </h1>
            <button onClick={() => {
                this.setState(previousState => produce(previousState, (draft) => {
                    draft.value += 1
                }))
            }}>+</button>
        </>
    }
    componentDidMount() {
        console.log('ComponentDidMount')
    }
    componentDidUpdate() {
        console.log('ComponentDidUpdate')
    }
}



const App = () => {
    return <>
        <Counter></Counter>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />
);
.....................................................................................
...................................................................................
			Component Lifes and API Call
...................................................................................

In order to talk to REST API, react has no any opinion regarding which ajax libs should be used

Popular ajax libs used inside react

1.fetch
2.axios

import { produce } from 'immer';
import React from 'react';
import ReactDOM from 'react-dom/client';


class Posts extends React.Component {
    state = {
        posts: [], //data
        error: null,
        isLoading: false
    }

    //render
    render() {
        const { posts, error, isLoading } = this.state
        if (error) {
            return <div style={{ marginLeft: 50 }}>
                <h1>Error : {error.message}</h1>
            </div>
        } else if (!isLoading) {
            return <h1 style={{ textAlign: 'center' }}>üõ¥</h1>
        } else {
            return <div style={{ marginLeft: 50 }}>
                <h1>Posts</h1>
                <hr />
                <ul>
                    {posts.map(post => {
                        return <li>{post.title}</li>
                    })}
                </ul>
            </div>

        }
    }

  //https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
    async componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        try {
            const response = await fetch(url)
            const posts = await response.json()
            console.log(posts)
            this.setState(previousState => {
                return produce(previousState, draft => {
                    draft.posts = posts
                    draft.isLoading = true
                    draft.error = previousState.error
                })
            })
        }
        catch (err) {
            this.setState(previousState => {
                return produce(previousState, draft => {
                    draft.error = err
                })
            })
        }

    }

}



const App = () => {
    return <>
        <Posts></Posts>
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

.....................................................................................
			Functional components, state,life cycle methods
					(Hooks)
....................................................................................


What is hook and why?
Hooks are simple javascript function which holds Component's logic outside component.

"Incase of class component , if you define a biz logic, the similar logic if you have in another component, we can't reuse."

React 16 introduced a feature called hooks, by using hooks you can eleminate class components completly, by keeping functional components

Hooks abstract complex  biz logic in reusable mannager.

React provides lot of built in hooks to build app , as simple as possible , mean time you can create your own hooks (custom hooks).

Hooks features:

1.hook is simple js function
2.hook can take input and also return values
3.every hook function starts with "useHookName"


Common Built in Hooks

1.useState
   To declare state and mutation inside functions
2.useEffect
   It represents "Life Methods" - compoentDidMount,componentDidUpdate
3.useContext
4.useRef
5.useMemo
6.useCallback
etc......


Thanks class components,goodbye to class components....

State declaration,mutation:
...........................

useState:

Syntax:

const [state,setState]=useState(initalState)

state is just variable it could be any thing
setState -  pure function its name generally setVariableName

const [counter,setCounter]=useState(initalState)

initalState could be

1.primitive values numbers,string,boolean
2.objects
3.arrays

const [counter,setCounter]=useState(0)
const [state,setState]=useState('hello')
const [state,setState]=useState(false)
const [state,setState]=useState(null)
const [state,setState]=useState({count:0})
const [state,setState]=useState([])

.....................................................................................
				Hooks
....................................................................................


What is hook and why?
Hooks are simple javascript function which holds Component's logic outside component.

"Incase of class component , if you define a biz logic, the similar logic if you have in another component, we can't reuse."

React 16 introduced a feature called hooks, by using hooks you can eleminate class components completly, by keeping functional components

Hooks abstract complex  biz logic in reusable mannager.

React provides lot of built in hooks to build app , as simple as possible , mean time you can create your own hooks (custom hooks).



Hooks features:

1.hook is simple js function
2.hook can take input and also return values
3.every hook function starts with "useHookName"


Common Built in Hooks

1.useState
   To declare state and mutation inside functions
2.useEffect
   It represents "Life Methods" - compoentDidMount,componentDidUpdate
3.useContext
4.useRef
5.useMemo
6.useCallback
etc......


Thanks class components,goodbye to class components....

State declaration,mutation:
...........................

useState:

Syntax:

const [state,setState]=useState(initalState)

state is just variable it could be any thing
setState -  pure function its name generally setVariableName

const [counter,setCounter]=useState(initalState)

initalState could be

1.primitive values numbers,string,boolean
2.objects
3.arrays

const [counter,setCounter]=useState(0)
const [state,setState]=useState('hello')
const [state,setState]=useState(false)
const [state,setState]=useState(null)
const [state,setState]=useState({count:0})
const [state,setState]=useState([])

import ReactDOM from 'react-dom/client';
import './index.css'
import { useState } from 'react';

//hook based component

const Counter = (props) => {

    //state declaration.
    const [counter, setCounter] = useState(0)

    const onIncrement = () => {
        //calling setCounter
        // setCounter((prevState) => {
        //     return prevState + 1
        // })
        setCounter(counter + 1)
    }
    return <div>
        <h1>Counter {counter}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            setCounter(counter - 1)
        }}>-</button>

    </div>
}



const App = () => {
    return <>
        <Counter />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);


Multi state:
import React, { useState } from 'react';
import ReactDOM from 'react-dom/client';

const Review = () => {
    const [like, setLike] = useState(0)
    const [dislike, setDislike] = useState(0)
    return <div>
        <h1>Review App</h1>
        <h3>Like {like} DisLike {dislike}</h3>
        <button onClick={() => setLike(like + 1)}>Like</button>
        <button onClick={() => setDislike(like + 1)}>DisLike</button>
    </div>
}

const App = () => {
    return <>
        <Review />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

....................................................................................
			  Objects and hooks using immer
.....................................................................................

import ReactDOM from 'react-dom/client'
import './index.css'
import { useState } from 'react'
import { produce } from 'immer'


const Review = () => {
    //state declaration
    const [review, setReview] = useState({ like: 0, dislike: 0 })
    return <>
        <h1>Review App</h1>
        <h3>Like {review.like} Dislike {review.dislike}</h3>
        <button onClick={() => {
            setReview(prevState => {
                return produce(prevState, (draft) => {
                    draft.like += 1
                })
            })
        }}>Like</button>
        <button onClick={() => {
            setReview(prevState => {
                return produce(prevState, (draft) => {
                    draft.dislike += 1
                })
            })
        }}>Dislike</button>

    </>

}


const App = () => {
    return <>
        <Review />
    </>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <App />
)
....................................................................................
			useEffect and api call
comonentDidMount,componentDidupdate,componentWillUnMount
    =>useEffect

componentDidMount
useEffect(()=>{},[])
useEffect(()=>{})

ComponentDidUpdate
useEffect(()=>{},[state])
 here if state is updated, then this hook will be called





import { produce } from 'immer';
import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'


const Posts = () => {
    const [post, setPost] = useState({
        posts: [], //data
        error: null,
        isLoading: false
    })

    //api
    async function fetchPosts() {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        try {
            const response = await fetch(url)
            const posts = await response.json()
            console.log(posts)
            setPost(previousState => {
                return produce(previousState, draft => {
                    draft.posts = posts
                    draft.isLoading = true
                    draft.error = previousState.error
                })
            })
        }
        catch (err) {
            setPost(previousState => {
                return produce(previousState, draft => {
                    draft.error = err
                })
            })
        }
    }

    //componentDidMount
    useEffect(() => {
        //api logic
        fetchPosts()

        //componentwillunMount
        return () => {
            console.log('any clean up activity')
        }

    }, [])

    if (post.error) {
        return <div style={{ marginLeft: 50 }}>
            <h1>Error : {post.error.message}</h1>
        </div>
    } else if (!post.isLoading) {
        return <h1 style={{ textAlign: 'center' }}>üõ¥</h1>
    } else {
        return <div style={{ marginLeft: 50 }}>
            <h1>Posts</h1>
            <hr />
            <ul>
                {post.posts.map(post => {
                    return <li key={post.id}>{post.title}</li>
                })}
            </ul>
        </div>

    }



}

const App = () => {
    return <>
        <Posts />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
.....................................................................................
			      Redux
...................................................................................

.....................................................................................
			 Redux -State Management
.....................................................................................

What is state?
 State is nothing data.

State is managed within component.

What if i want to share the state across the application,there is pattern called "Lift up the state", pass as prop.

In state management , redux is going to act as state layer, react is going act as UI layer.

React and Redux is based on the design pattern "Flux Pattern"


https://facebookarchive.github.io/flux/


Action---->dispatcher----->Store<--->[Reducer] 
			    |
			    |
			 View-React


What is Redux -  Red-reducer + ux (Flux) => Reducer + Flux

What is Reducer?
  Reducer is pure function, which accepts input, returns immutable object...
  Reducer is having biz logic.
  Who calls reducer, reducer is called by store..
  UI Layer never communicates biz logic (reducer) directly.
  UI Layer sends request(action) --via dispatcher---to the store, then store reacts   to that

Core Concepts or Principles:
............................

1.State:
   Redux maintains or stores the data in "single object"Redux is going to store all 
component state into one single object -Application State

const appState = {
  ....   
} called as application state.

How appState is identified for each compoent?

 Based on category/module.

const appState = {
  
  order: {
    
  },
  customer: {},
  product:{}

} 
2.Store
   Store is object where Redux application state lives.
   Store offers api to communicate from react and redux to react
   Store is entry and exit point of react and redux
   Per application , there is single store, that store is having state..

3.reducer
    You know very well how to mutate and where mutate state in react
     ->Inside setState pure function.
    Reducer is pure function which returns immutable object.

4.actions
    An action is like request in webserver, redux actions are plain javascript object
 eg:
  let counterAction = {
	type:'counter/increment'
  }
 action may take input also called payload
  let counterByAmount = {
   type:'counter/increment',
   payload:12
 }
5.Dispatcher 
  It is transporter which transport action object from react to redux
  Dispatcher is represented by a method called "dispatch"
  dispatch is part of "Store object"
  store.dispatch(action)

....................................................................................
..................................................................................					Building Redux
...................................................................................

in order to start redux we have two patterns

1.old redux  - redux.js -https://redux.js.org/
2.new redux called "Redux toolkit" -https://redux-toolkit.js.org/


We are going to use "Redux toolkit"

There are two ways create app:

1.create react only, and update redux

Using Vite:
npm create vite router-app  --template react
npm install @reduxjs/toolkit  react-redux

2.create react-redux app one short

Using vite

npx degit reduxjs/redux-templates/packages/vite-template-redux my-app

Using create-react-app

npx create-react-app myreduxapp --template redux
.....................................................................................

Level-0 :State inside component.

import React, {useState} from 'react'
import ReactDOM from 'react-dom/client'

const Review = ()=> {
  const [like, setLike] = useState(0)
 
  return <>
    <h1>Like {like}</h1>
    <button onClick={() => {
            setLike(like + 1)
        }}>+</button>
  </>
}

const App = () => <div>
     <Review/>
</div>

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
...................................................................................
Level:1 : Moving State , Mutation into redux

import React from 'react'
import ReactDOM from 'react-dom/client'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'


//reducer
const ReviewReducer = (like = 10, action) => {
    //biz
    switch (action.type) {
        case 'review/like':
            return like + 1
        default:
            return like //default state/inital state
    }
}

//create Store Object

const store = configureStore({
    reducer: {
        review: ReviewReducer
    }
})

///////////////////////////////////////////////////////
const Review = () => {

    //hook to get redux state
    const like = useSelector(state => {
        //appstate.reducerName
        return state.review
    })
    const dispatch = useDispatch()

    const onLike = () => {
        //send action via dispatcher
        dispatch({
            type: 'review/like'
        })
    }

    return <>
        <h1>Like {like}</h1>
        <button onClick={onLike}>+</button>
    </>
}

const App = () => <div>
    <Review />
</div>

ReactDOM.createRoot(document.getElementById('root')).render(
    <Provider store={store}>
        <React.StrictMode>
            <App />
        </React.StrictMode>
    </Provider>

)
..................................................................................
configureStore() - RTK api

=>to provide simplified configuration with default settings.

type ConfigureEnhancersCallback = (
  defaultEnhancers: StoreEnhancer[]
) => StoreEnhancer[]

interface ConfigureStoreOptions<
  S = any,
  A extends Action = AnyAction,
  M extends Middlewares<S> = Middlewares<S>
> {
  /**
   * A single reducer function that will be used as the root reducer, or an
   * object of slice reducers that will be passed to `combineReducers()`.
   */
  reducer: Reducer<S, A> | ReducersMapObject<S, A>

  /**
   * An array of Redux middleware to install. If not supplied, defaults to
   * the set of middleware returned by `getDefaultMiddleware()`.
   */
  middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M

  /**
   * Whether to enable Redux DevTools integration. Defaults to `true`.
   *
   * Additional configuration can be done by passing Redux DevTools options
   */
  devTools?: boolean | DevToolsOptions

  /**
   * The initial state, same as Redux's createStore.
   * You may optionally specify it to hydrate the state
   * from the server in universal apps, or to restore a previously serialized
   * user session. If you use `combineReducers()` to produce the root reducer
   * function (either directly or indirectly by passing an object as `reducer`),
   * this must be an object with the same shape as the reducer map keys.
   */
  preloadedState?: DeepPartial<S extends any ? S : S>

  /**
   * The store enhancers to apply. See Redux's `createStore()`.
   * All enhancers will be included before the DevTools Extension enhancer.
   * If you need to customize the order of enhancers, supply a callback
   * function that will receive the original array (ie, `[applyMiddleware]`),
   * and should return a new array (such as `[applyMiddleware, offline]`).
   * If you only need to add middleware, you can use the `middleware` parameter instead.
   */
  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback
}

function configureStore<S = any, A extends Action = AnyAction>(
  options: ConfigureStoreOptions<S, A>
): EnhancedStore<S, A>
.....................................................................................
			Multi State/Multiple Reducers

import React, { useState } from 'react'
import ReactDOM from 'react-dom/client'
import { produce } from 'immer'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'
import './index.css'

const LikeReducer = (review = { like: 10 }, action) => {
    //logic
    switch (action.type) {
        case 'LIKE':
            return produce(review, draft => {
                draft.like += 1
            })
        default:
            return review;
    }
}
const DislikeReducer = (review = { dislike: 10 }, action) => {
    switch (action.type) {
        case 'DISLIKE':
            return produce(review, draft => {
                draft.dislike += 1
            })

        default:
            //default state- initali state
            return review;
    }
}

const appStore = configureStore({
    reducer: {
        likeReducer: LikeReducer,
        dislikeReducer: DislikeReducer
    }
})

const Like = () => {
    const review = useSelector(appState => {
        return appState.likeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Like</h1>
        <h1>like :{review.like}</h1>
        <button onClick={() => {
            dispatch({ type: 'LIKE' })
        }}>Like</button>

    </>

}
const Dislike = () => {
    const review = useSelector(appState => {
        return appState.dislikeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Dislike</h1>
        <h1>dislike :{review.dislike}</h1>
        <button onClick={() => {
            dispatch({ type: 'DISLIKE' })
        }}>Like</button>

    </>

}


const Review = () => <>
    <Like />
    <Dislike />
</>


const App = () => {

    //React -Redux binding Component
    return <Provider store={appStore}>
        <Review></Review>
    </Provider>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
			  Action constant


how to declare actions? what is standard naming convention?			


action name must be string
action name must match domain/actionName
eg:
   'review/like'
action name can be captialized or complete smaller.

import React, { useState } from 'react'
import ReactDOM from 'react-dom/client'
import { produce } from 'immer'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'
import './index.css'


//action constant
const like = 'review/like'
const dislike = 'review/dislike'


const LikeReducer = (review = { like: 10 }, action) => {
    //logic
    switch (action.type) {
        case like:
            return produce(review, draft => {
                draft.like += 1
            })
        default:
            return review;
    }
}
const DislikeReducer = (review = { dislike: 10 }, action) => {
    switch (action.type) {
        case dislike:
            return produce(review, draft => {
                draft.dislike += 1
            })

        default:
            //default state- initali state
            return review;
    }
}

const appStore = configureStore({
    reducer: {
        likeReducer: LikeReducer,
        dislikeReducer: DislikeReducer
    }
})

const Like = () => {
    const review = useSelector(appState => {
        return appState.likeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Like</h1>
        <h1>like :{review.like}</h1>
        <button onClick={() => {
            dispatch({ type: like })
        }}>Like</button>

    </>

}
const Dislike = () => {
    const review = useSelector(appState => {
        return appState.dislikeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Dislike</h1>
        <h1>dislike :{review.dislike}</h1>
        <button onClick={() => {
            dispatch({ type: dislike })
        }}>Like</button>

    </>

}


const Review = () => <>
    <Like />
    <Dislike />
</>


const App = () => {

    //React -Redux binding Component
    return <Provider store={appStore}>
        <Review></Review>
    </Provider>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
			Payload-Input to reducer
.....................................................................................

Without input action syntax:

const likeAction = {
  type:'review/like'
}

with pay load(input)
const likeAction = {
  type:'review/like',
  payload:value
}
here "payload" is just convention name only, we can use any name.

import React, { useState } from 'react'
import ReactDOM from 'react-dom/client'
import { produce } from 'immer'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'
import './index.css'


//action constant
const like = 'review/like'
const dislike = 'review/dislike'


const LikeReducer = (review = { like: 10 }, action) => {
    //logic
    switch (action.type) {
        case like:
            return produce(review, draft => {
                draft.like += action.payload
            })
        default:
            return review;
    }
}
const DislikeReducer = (review = { dislike: 10 }, action) => {
    switch (action.type) {
        case dislike:
            return produce(review, draft => {
                draft.dislike += 1
            })

        default:
            //default state- initali state
            return review;
    }
}

const appStore = configureStore({
    reducer: {
        likeReducer: LikeReducer,
        dislikeReducer: DislikeReducer
    }
})

const Like = () => {
    const review = useSelector(appState => {
        return appState.likeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Like</h1>
        <h1>like :{review.like}</h1>
        <button onClick={() => {
            dispatch({ type: like, payload: 2 })
        }}>Like</button>

    </>

}
const Dislike = () => {
    const review = useSelector(appState => {
        return appState.dislikeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Dislike</h1>
        <h1>dislike :{review.dislike}</h1>
        <button onClick={() => {
            dispatch({ type: dislike })
        }}>Like</button>

    </>

}


const Review = () => <>
    <Like />
    <Dislike />
</>


const App = () => {

    //React -Redux binding Component
    return <Provider store={appStore}>
        <Review></Review>
    </Provider>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
................................................................................
			Payload -input
..................................................................................

import React, { useState } from 'react'
import ReactDOM from 'react-dom/client'
import { produce } from 'immer'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'
import './index.css'


//action constant
const like = 'review/like'
const dislike = 'review/dislike'


const LikeReducer = (review = { like: 10 }, action) => {
    //logic
    switch (action.type) {
        case like:
            return produce(review, draft => {
                draft.like += action.payload.value
            })
        default:
            return review;
    }
}
const DislikeReducer = (review = { dislike: 10 }, action) => {
    switch (action.type) {
        case dislike:
            return produce(review, draft => {
                draft.dislike += 1
            })

        default:
            //default state- initali state
            return review;
    }
}

const appStore = configureStore({
    reducer: {
        likeReducer: LikeReducer,
        dislikeReducer: DislikeReducer
    }
})

const Like = () => {
    const review = useSelector(appState => {
        return appState.likeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Like</h1>
        <h1>like :{review.like}</h1>
        <button onClick={() => {
            dispatch({ type: like, payload: { value: 3 } })
        }}>Like</button>

    </>

}
const Dislike = () => {
    const review = useSelector(appState => {
        return appState.dislikeReducer
    })
    const dispatch = useDispatch()

    return <>
        <h1>Dislike</h1>
        <h1>dislike :{review.dislike}</h1>
        <button onClick={() => {
            dispatch({ type: dislike })
        }}>Like</button>

    </>

}


const Review = () => <>
    <Like />
    <Dislike />
</>


const App = () => {

    //React -Redux binding Component
    return <Provider store={appStore}>
        <Review></Review>
    </Provider>
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)
.....................................................................................
			Reducers Deep dive
.....................................................................................
We have various ways of writing reducers.

Patterns:
1.old way
const LikeReducer = (review = { like: 10 }, action) => {
    //logic
    switch (action.type) {
        case like:
            return produce(review, draft => {
                draft.like += action.payload.value
            })
        default:
            return review;
    }
}
2.Modern way.

2.1.Using createReducer api

1.It is utillity function from redux-toolkit.
2.It reduces lot of boiler plate code , provides standards based coding
3.It is offering built in immer js api,so, no need of using "produce" directly..
4.No need of switch..case and actions...

createReducer api coding has 1 pattern

1.builder pattern

Old reducer code:
const ReviewReducer = (state = { like: 0, dislike: 0 }, action) => {
    //biz
    switch (action.type) {
        case like:
            return produce(state, (draft) => {
                draft.like += 1
            })
        case dislike:
            return produce(state, (draft) => {
                draft.dislike += 1
            })
        default:
            return state //default state/inital state
    }
}
=>It handles for a specific action types.
=>It matching against a range of actions
=>It handles a default case

Syntax:

const reducer =createReducer(initalState,(builder)=>{
  builder.addCase(actionName,(state,action)=>{
     //immer js code: produce function is built in
     state.value++
  }).
  builder.addCase(actionName,(state,action)=>{
     //immer js code: produce function is built in
     state.value--
  }).addDefaultCase((state,action)=>{})
})

